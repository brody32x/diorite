#!/usr/bin/python3

# Copyright 2014 Jiří Janoušek <janousek.jiri@gmail.com>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import re

S = r"[ \t\r\f\v]" 
NAMESPACE_RE = re.compile(r"^" + S + r"*namespace" + S + r"+(?P<name>(\w+\.)*\w+)" + S + r"*\{?" + S + r"*$", re.M)
TEST_CASE_RE = re.compile(r"^\s*public\s+class\s+(?P<name>(\w+)\w+Test)\s*:")
TEST_FUNC_RE = re.compile(r"^\s*public\s+(?P<async>async\s+)?void\s+(?P<name>test_\w+)\s*\(\s*\)\s*\{?\s*$")

header_block = """\
/* Generated by Diorite Testgen */
/* Included code blocks are in public domain */
"""

start_block = """
public static int main(string[] args)
{
	Test.init(ref args);
"""

end_block = """
	return Test.run();
}
"""

run_block = """
void %s()
{
	var test = new %s();
	test.set_up();
	test.%s();
	test.tear_down();
	test.summary();
}
"""

def parse_source(source):
	test_cases = []
	with open(source, "tr") as f:
		data = f.read()
	
	matches = tuple(NAMESPACE_RE.finditer(data))
	if len(matches) > 1:
		ns = ', '.join(m.group("name") for m in matches)
		raise Exception("Only one namespace declaration is supported, but %s found: %s." % (len(matches), ns))
	
	if matches:
		namespace = matches[0].group("name") + "."
	else:
		namespace = ""
	
	test_case = None
	for line in data.splitlines():
		m = TEST_CASE_RE.match(line)
		if m:
			test_case = namespace + m.group("name")
		else:
			m = TEST_FUNC_RE.match(line)
			if m:
				if test_case is None:
					raise Exception("Test method without a test case: %s" % m.group(0).strip())
				method = m.group("name")
				path = "/" + (test_case + "." + method).replace(".", "/")
				test_cases.append((path, test_case, method, bool(m.group("async"))))
	
	return test_cases

def write_tests(out, test_cases):
	if test_cases:
		runners_block = []
		register_block = []
		for path, klass, method, async in test_cases:
			
			if async:
				continue
			run_func = "run" + path.replace("/", "_")
			runners_block.append(run_block % (run_func, klass, method))
			register_block.append('\tTest.add_func("%s", %s);' % (path, run_func))
		
		out.write(header_block)
		out.write("".join(runners_block))
		out.write(start_block)
		out.write("\n".join(register_block))
		out.write(end_block)
		out.write("\n")

def generate(output, sources):
	test_cases = []
	errors = []
	
	for source in sources:
		try:
			test_cases.extend(parse_source(source))
		except Exception as e:
			errors.append((source, e))
	
	write_tests(output, test_cases)
	
	return errors

if __name__ == "__main__":
	import argparse
	import sys
	parser = argparse.ArgumentParser()
	parser.add_argument("source", nargs='+', help="source files to extract test cases from")
	parser.add_argument("-o", "--output", type=argparse.FileType('w'), help="where to write generated test runner")
	args = parser.parse_args()
	
	errors = generate(args.output or sys.stdout, args.source)
	
	if errors:
		for e in errors:
			sys.stderr.write("*** Errror in %s: %s\n" % e)
		sys.exit(1)
	else:
		sys.exit(0)
