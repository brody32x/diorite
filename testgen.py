#!/usr/bin/python3

# Copyright 2014 Jiří Janoušek <janousek.jiri@gmail.com>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met: 
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import re

S = r"[ \t\r\f\v]" 
NAMESPACE_RE = re.compile(r"^" + S + r"*namespace" + S + r"+(?P<name>(\w+\.)*\w+)" + S + r"*\{?" + S + r"*$", re.M)
TEST_CASE_RE = re.compile(r"^\s*public\s+(?P<abstract>abstract\s+)?class\s+(?P<name>(\w+)\w+Test)\s*:\s*(?P<parents>.+)")
TEST_FUNC_RE = re.compile(r"^\s*public\s+(?P<async>async\s+)?void\s+(?P<name>test_\w+)\s*\(\s*\)\s*\{?\s*$")

header_block = """\
/* Generated by Diorite Testgen */
/* Included code blocks are in public domain */
"""

start_block = """
public static int main(string[] args)
{
	Test.init(ref args);
"""

end_block = """
	return Test.run();
}
"""
	
run_block = """
void %s()
{
	var test = new %s();
	test.set_up();
	test.%s();
	test.tear_down();
	test.summary();
}
"""

run_block_async = """
void {func}()
{{
	var test = new {klass}();
	test.set_up();
	var loop = new MainLoop();
	test.{test}.begin((res) =>
	{{
		loop.quit();
	}});
	loop.run();
	test.tear_down();
	test.summary();
}}
"""

class TestCase:
	def __init__(self, name, abstract, ns, parents, source):
		self.name = name
		self.abstract = abstract
		self.ns = ns
		self.parents = parents
		self.tests = []
		self.source = source
	
	def __str__(self):
		return ("abstract {} : {}" if self.abstract else "{} : {}").format(
			self.name, ",".join(self.parents))
	
	def __repr__(self):
		return "<{}>".format(self)

class Test:
	def __init__(self, name, async):
		self.name = name
		self.async = async
	
	def __str__(self):
		return "{} {}".format("async" if self.async else "sync", self.name)
	
	def __repr__(self):
		return "<{}>".format(self)

def parse_source(test_cases, source):
	with open(source, "tr") as f:
		data = f.read()
	
	matches = tuple(NAMESPACE_RE.finditer(data))
	if len(matches) > 1:
		ns = ', '.join(m.group("name") for m in matches)
		raise Exception("Only one namespace declaration is supported, but %s found: %s." % (len(matches), ns))
	
	if matches:
		namespace = matches[0].group("name") + "."
	else:
		namespace = ""
	
	test_case = None
	for line in data.splitlines():
		m = TEST_CASE_RE.match(line)
		if m:
			name = namespace + m.group("name")
			parents = [i for i in m.group("parents").split() if i != "Diorite.TestCase"]
			abstract = bool(m.group("abstract"))
			test_cases[name] = test_case = TestCase(name, abstract, namespace, parents, source)
		else:
			m = TEST_FUNC_RE.match(line)
			if m:
				if test_case is None:
					raise Exception("Test method without a test case: %s" % m.group(0).strip())
				test_case.tests.append(Test(m.group("name"), bool(m.group("async"))))

def append_tests(runners_block, register_block, test_case, klass=None):
	if klass is None:
		klass = test_case
	 
	for parent in test_case.parents:
		append_tests(runners_block, register_block, parent, klass)
	
	for t in test_case.tests:
		path = "/" + klass.name.replace(".", "/") + "/" + t.name[5:]
		run_func = "run" + path.replace("/", "_")
		if not t.async:
			runners_block.append(run_block % (run_func, klass.name, t.name))
		else:
			runners_block.append(run_block_async.format(func=run_func, klass=klass.name, test=t.name))
		register_block.append('\tTest.add_func("%s", %s);' % (path, run_func))

def write_tests(out, test_cases):
	if test_cases:
		runners_block = []
		register_block = []
		for test_case in test_cases.values():
			if not test_case.abstract:
				append_tests(runners_block, register_block, test_case)
		
		out.write(header_block)
		out.write("".join(runners_block))
		out.write(start_block)
		out.write("\n".join(register_block))
		out.write(end_block)
		out.write("\n")

def find_test_cases(test_cases, sources):
	errors = []
	for source in sources:
		try:
			parse_source(test_cases, source)
		except Exception as e:
			errors.append((source, e))
	return errors

def find_parents(test_cases):
	errors = []
	for test_case in test_cases.values():
		parents = []
		ns = test_case.ns
		for parent in test_case.parents:
			print(ns, parent)
			try:
				parents.append(test_cases[parent])
			except KeyError as e:
				try:
					parents.append(test_cases[ns + parent])
				except KeyError as e:
					errors.append((test_cas.source, "Cannot find parent class {}.".format(parent)))
		test_case.parents = parents
	return errors

def generate(output, sources):
	test_cases = {}
	errors = find_test_cases(test_cases, sources)
	errors.extend(find_parents(test_cases))
	write_tests(output, test_cases)	
	return errors

if __name__ == "__main__":
	import argparse
	import sys
	parser = argparse.ArgumentParser()
	parser.add_argument("source", nargs='+', help="source files to extract test cases from")
	parser.add_argument("-o", "--output", type=argparse.FileType('w'), help="where to write generated test runner")
	args = parser.parse_args()
	
	errors = generate(args.output or sys.stdout, args.source)
	
	if errors:
		for e in errors:
			sys.stderr.write("*** Errror in %s: %s\n" % e)
		sys.exit(1)
	else:
		sys.exit(0)
